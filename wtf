from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes 
from cryptography.hazmat.primitives.asymmetric import padding 
from cryptography.exceptions import * 
def keygen():
  private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048,backend=default_backend())
  public_key =  private_key.public_key() 
  return private_key,public_key 
  def sign_(message, private_key):
    signature =private_key.sign(message,padding.PSS(mgf=padding.MGF1(hashes.SHA256()),salt_length=padding.PSS.MAX_LENGTH),hashes.SHA256())
    return signature 
  def verify(message,signature, public_key):
    try:
      public_key.verify(signature, message,padding.PSS(mgf=padding.MGF1(hashes.SHA256()),salt_length=padding.PSS.MAX_LENGTH),hashes.SHA256())
      return True 
    except InvalidSignature:
      return False

if __name__ == '__main__':
  priv, pub = keygen() 
  message = b' I authorise $1,000 dollars to be sent to Ben' 
  signature = sign_(message,priv) 
  correct = verify(message, signature, pub)

 if correct:
   print('message verified - send the money ')
 else:
   print('this does not open with the public key. Bad signature.')

 priv2, pub2 = keygen() 
 signature2 =sign_(message, priv2) 
 correct =verify(message, signature2, pub)
 if correct:
  print('message verified - send the money ')
 else:
  print('this has been signed by someone else. Do not send money') 
  tamper =message + b'give me money'
  correct = verify(tamper, signature, pub)
 if correct:
  print('message verified - send the money ')
 else:
  print('this is not the original message') 
